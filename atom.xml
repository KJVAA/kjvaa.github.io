<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kjvaa&#39;s note</title>
  
  <subtitle>被动强制ing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.kjvaa.online/"/>
  <updated>2020-04-26T05:20:33.455Z</updated>
  <id>http://blog.kjvaa.online/</id>
  
  <author>
    <name>kjvaa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++快速入门到实战记录(一)</title>
    <link href="http://blog.kjvaa.online/post/2020/04/23/C-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95-%E4%B8%80/"/>
    <id>http://blog.kjvaa.online/post/2020/04/23/C-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95-%E4%B8%80/</id>
    <published>2020-04-23T06:40:02.000Z</published>
    <updated>2020-04-26T05:20:33.455Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>本文是根据<a href="https://www.bilibili.com/video/BV1p7411v7ou" target="_blank" rel="noopener">编程内功之30小时快速精通C++和外挂实战课程</a>所做的课程笔记<br />这个课程讲的不错，推荐有任何其他编程语言基础的人去听。当然视频为搬运(原讲师就在下方评论)</p>          </div><div class="note warning">            <h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><p>对于一些vs的使用细节本文并不会花过多笔墨<br />最后请不要盲目相信任何博客</p>          </div><h2 id="起步"><a class="markdownIt-Anchor" href="#起步"></a> 起步</h2><h3 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> helloworld</h3><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    cout&lt;&lt;&quot;hello world&quot; &lt;&lt;endl;    getchar();    return 0;}</code></pre><p>初学者看到这里如果你眼尖的话会一眼看明白几件事情，首先，<font style="color:red">cout</font>和<font style="color:red">cout</font>这俩个关键字的作用就很明显。输出及换行，结合流操作符 <em>“&lt;&lt;”</em>（左移运算符） 实现字符输出。当然C++也<em>一定程度</em>上兼容C语法printf()一样可用使用，当然啦，如果你学过C就知道后者需要指定参数格式。那么还有一个呢就是</p><pre><code>using namespace std;</code></pre><p>你如果看到其他地方的输出语句他可能是这样写的</p><pre><code>std::cout&lt;&lt;&quot;hello world&quot; &lt;&lt;std::endl;</code></pre><p>其实也很好理解，如果在Java中没有import想要用上其他包的类你可能需要你整个包的路径都写进来再使用想用的类。</p><h3 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h3><p>cout是输出那输入不言而喻那就是 <s>cinto</s> <s>cEnter</s> cin(没错正是在下)，那问题来了，你输入了的东西给谁啊怎么给啊，这时候我们用上与之前 <em>“&lt;&lt;”</em>（左移运算符）相反的运算符—— <em>“&gt;&gt;”</em>（右移运算符）</p><blockquote><p>int age;<br />cin &gt;&gt; age;<br />cout&lt;&lt;“age is”&lt;&lt;age&lt;&lt;endl;</p></blockquote><p>由于cin或getChar()如果接收到回车会往下执行，所以有可能会出现闪过。<br /><em><center>即如果按下回车会里面退出程序，这时候可以在vs的“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”取消掉√或者在代码后面写getchar()即可</center></em><br />cin行不行呢？答案是不行或者没必要，因为cin&gt;&gt;这个方法是把接收到的东西给到右边，你这个难道还要把</p><blockquote><p>cin &gt;&gt; age;</p></blockquote><p>再执行一边？所以说没有必要吧，况且这种command交互并不是C++原生的，在相关平台上各自的shell的交互肯定比这个强大的多。</p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><h3 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h3><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p><h4 id="引申"><a class="markdownIt-Anchor" href="#引申"></a> 引申</h4><p>如果你是有其他语言的经验那这个太熟悉了，比如在java中也有相关的东西</p><blockquote><p><a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener"><em><center>Java 重写(Override)与重载(Overload)</center></em></a></p><ul><li>一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li><li>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li><li>最常用的地方就是构造器的重载。</li><li>。。。。。</li></ul></blockquote><p>说人话，就是同一个函数名参数的类型个数顺序的不同则构成函数的重载，它是用来干嘛的呢？你想象一下这样的场景，说你今天做了一个功能你为了描述它取了一个好听的名字，明天你又写了一个结果呢，感觉上好像这个功能上好像跟昨天的写相似，那你去名叫那个<em>好听的名字A(1)<em>吧，再后来你又写了几个你觉得还是不过瘾你就取名</em>好听的名字A(1)B(2)C(3)。。。。。</em>。时间一长，你发现欸，我他妈写的什么东西，有的人说了我有注释难不倒我。那这就跟面向的对象的多态定义背道而驰了——消息或操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，鲜明的例子就是构造函数重载。重载极大丰富了代码的健壮性，特别是能让你减少对数据类型或者格式类型检查。当然你说，这还是麻烦，我写了一堆重载那不跟我原来的想法背道而驰吗？嗯，在c++ 中引入了可变模版参数（variadic templates），可以更进一步的解决上述问题，当然那是后话了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"int method run"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double method run"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> num3 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">double</span> num4 = <span class="number">4.669</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(num1,num2)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(num3, num4) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c实现函数重载的底层一窥"><a class="markdownIt-Anchor" href="#c实现函数重载的底层一窥"></a> c++实现函数重载的底层一窥</h4><p>c++作为高级语言，它并不能直接跑在硬件上，他需要编译器把编程汇编再由汇编映射到二进制机器码再来执行。再通过VS对上述代码的反编译我会看到了他的汇编代码</p><div class="note warning">            <p><em><center style= "color:red">此处的汇编是夹杂经由VS转译的伪代码的版本</center></em></p>          </div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C7 45 F8 01 00 00 00 mov         dword ptr [num1],1  </span><br><span class="line">C7 45 EC 02 00 00 00 mov         dword ptr [num2],2  </span><br><span class="line">F2 0F 10 05 60 9B 5D 00 movsd       xmm0,mmword ptr [__real@40091eb851eb851f (05D9B60h)]  </span><br><span class="line">F2 0F 11 45 DC       movsd       mmword ptr [num3],xmm0  </span><br><span class="line">F2 0F 10 05 70 9B 5D 00 movsd       xmm0,mmword ptr [__real@4012ad0e56041893 (05D9B70h)]  </span><br><span class="line">F2 0F 11 45 CC       movsd       mmword ptr [num4],xmm0  </span><br><span class="line">8B F4                mov         esi,esp  </span><br><span class="line">68 A8 12 5D 00       push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (05D12A8h)  </span><br><span class="line">8B 45 EC             mov         eax,dword ptr [num2]  </span><br><span class="line">50                   push        eax  </span><br><span class="line">8B 4D F8             mov         ecx,dword ptr [num1]  </span><br><span class="line">51                   push        ecx  </span><br><span class="line">E8 7D EC FF FF       call        func (05D13B1h)  </span><br><span class="line">83 C4 08             add         esp,8  </span><br><span class="line">8B FC                mov         edi,esp  </span><br><span class="line">50                   push        eax  </span><br><span class="line">8B 0D DC D0 5D 00    mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (05DD0DCh)]  </span><br><span class="line">FF 15 A4 D0 5D 00    call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (05DD0A4h)]  </span><br><span class="line">3B FC                cmp         edi,esp  </span><br><span class="line">E8 38 EB FF FF       call        __RTC_CheckEsp (05D1285h)  </span><br><span class="line">8B C8                mov         ecx,eax  </span><br><span class="line">FF 15 A8 D0 5D 00    call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (05DD0A8h)]  </span><br><span class="line">3B F4                cmp         esi,esp  </span><br><span class="line">E8 29 EB FF FF       call        __RTC_CheckEsp (05D1285h)  </span><br><span class="line">8B F4                mov         esi,esp  </span><br><span class="line">68 A8 12 5D 00       push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (05D12A8h)  </span><br><span class="line">83 EC 08             sub         esp,8  </span><br><span class="line">F2 0F 10 45 CC       movsd       xmm0,mmword ptr [num4]  </span><br><span class="line">F2 0F 11 04 24       movsd       mmword ptr [esp],xmm0  </span><br><span class="line">83 EC 08             sub         esp,8  </span><br><span class="line">F2 0F 10 45 DC       movsd       xmm0,mmword ptr [num3]  </span><br><span class="line">F2 0F 11 04 24       movsd       mmword ptr [esp],xmm0  </span><br><span class="line">E8 0C EC FF FF       call        func (05D138Eh)</span><br></pre></td></tr></table></figure><p>看不懂？没有关系，你现在只需要理解三个个东西，mov*、<em>call以及</em>word(星号代表有相似指令或存储字长比如代码中的mov和movsd)。首先word，打一个不合理的比方说就是指你要装载多大的数据，dword就是double word俩个字节，怎么装载呢？那就是mov指令，格式是mov 目的操作数， 源操作数。那call呢，call就很容易理解了你看他后面的是什么——func (05D138Eh)，没错他就是调用，实际上这段真正汇编其实是这样写的</p><blockquote><p>call 05D138Eh</p></blockquote><p>没错，就是这个所谓的自定义函数func的地址，仔细观察你会发发现这个地址跟上面的还有一个func地址是不一样的，没错这就是原因，在汇层面上它调用的是不同地址所指向的函数。那你说，这不废话吗，这肯定是不一样的，就像俩个不同名的函数它最后的也是不一样的。你还真答对，所谓的函数重载在C++中真就是这么干的，怎么干的呢，就是你的代码输入的时候看到的同名的函数会被编译器重新修改成不同的名字，这里不同的编译器重新修改的规则不统一。啥呢？说再明白点就是把几个func()修改成func_1()func_2()func_3()或者funcA()funcB()funcC()，这时候就真相大白了。但是现在有一个问题，那就是不够直观啊。好那我们换个工具，ida。</p><blockquote><p><em><center>直接搬运百毒百科</center></em><br />交互式反汇编器专业版（Interactive Disassembler Professional），人们常称其为IDA Pro，或简称为IDA。是目前最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器！IDA Pro是一款交互式的，可编程的，可扩展的，多处理器的，交叉Windows或Linux WinCE MacOS平台主机来分析程序，被公认为最好的花钱可以买到的逆向工程利器。IDA Pro已经成为事实上的分析敌意代码的标准并让其自身迅速成为攻击研究领域的重要工具。它支持数十种CPU指令集其中包括Intel x86，x64，MIPS，PowerPC，ARM，Z80，68000，c8051等等。</p></blockquote><p>通过它处理后，我们得到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004010A3                 mov     eax, [ebp+num2]</span><br><span class="line">.text:004010A6                 push    eax             ; b</span><br><span class="line">.text:004010A7                 mov     ecx, [ebp+num1]</span><br><span class="line">.text:004010AA                 push    ecx             ; a</span><br><span class="line">.text:004010AB                 call    ?func@@YAHHH@Z  ; func(int,int)</span><br><span class="line">.text:004010B0                 add     esp, 8</span><br><span class="line">.text:004010B3                 push    eax</span><br><span class="line">.text:004010CD                 sub     esp, 8</span><br><span class="line">.text:004010D0                 movsd   xmm0, [ebp+num4]</span><br><span class="line">.text:004010D5                 movsd   [esp+24h+b], xmm0 ; b</span><br><span class="line">.text:004010DA                 sub     esp, 8</span><br><span class="line">.text:004010DD                 movsd   xmm0, [ebp+num3]</span><br><span class="line">.text:004010E2                 movsd   [esp+2Ch+a], xmm0 ; a</span><br><span class="line">.text:004010E7                 call    ?func@@YANNN@Z  ; func(double,double)</span><br></pre></td></tr></table></figure><p>我们从这里就可以看到俩个func()有明显的不同<br /><s>由于不同平台编译器以及vs版本ida版本的原因这里跟视频里不一样，就是一个意思</s></p><h3 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h3><p>C++允许函数设置默认参数，在调用时可以根据实际情况省略实参</p><h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4><blockquote><ol><li>默认参数只能从右到左</li><li><em>如果函数同时有声明，实现，默认参数只能放申明里</em></li><li>默认参数的值可以是常量、全局符号(全局变量，函数名)</li></ol></blockquote><h4 id="例一"><a class="markdownIt-Anchor" href="#例一"></a> 例一</h4><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>,<span class="keyword">int</span> b = <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    func(<span class="number">2</span>);</span><br><span class="line">    func(<span class="number">32</span>,<span class="number">34</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白话讲所谓默认就是可以让你缺少了那个参数，默认参数可以补上，甚至可以不写参数。第一个规则就是指上述代码的右侧的参数这个函数如果你要设置默认参数。函数你可以这么写</p><blockquote><p>func(int a = 1,int b = 2，int c= 3)</p></blockquote><p>但是你不能这么写</p><blockquote><p>func(int a = 1,int b，int c= 3)</p></blockquote><p>也不能这么写</p><blockquote><p>func(int a = 1,int b =2，int c)</p></blockquote><p>很好理解，你想啊你调用的时候只写一俩个参数或者不写，你中间或者后面没有参数那肯定会报错啊。</p><h4 id="例二"><a class="markdownIt-Anchor" href="#例二"></a> 例二</h4><p>有的写代码呢喜欢把函数写在后面，但是C++有的编译他是从上到下，你去调用它调用不到啊。很好解决</p><blockquote><p>void func(int a = 1,int b = 2);<br />int main(){<br />func();<br />func(2);<br />func(32,34);</p><p>return 0;</p><p>}</p><p>void func(int a ,int b ){<br />cout&lt;&lt;a+b&lt;&lt;endl;<br />}</p></blockquote><p>把申明丢前面就行，当然这好像是C的东西了，唯一要注意的就是规则所说的在同时有申明有实现的情况下，你的默认参数必须写在申明里，不然到时候谁选谁啊，这没啥说的。</p><h4 id="例三"><a class="markdownIt-Anchor" href="#例三"></a> 例三</h4><p><em>直接照搬视频了</em></p><pre><code>int age = 33;void test(){    cout&lt;&lt;&quot;test()&quot;&lt;&lt;endl;}void display(int a = 11,int b = 22,int c = age,void (*func)() = test){    cout&lt;&lt;&quot;a is&quot;&lt;&lt;a&lt;&lt;endl;    cout&lt;&lt;&quot;b is&quot;&lt;&lt;b&lt;&lt;endl;    cout&lt;&lt;&quot;c is&quot;&lt;&lt;c&lt;&lt;endl;    func();}int main(){    display();    return 0;}</code></pre><h3 id="extern-c"><a class="markdownIt-Anchor" href="#extern-c"></a> extern “C”</h3><p>extern &quot;C&quot;的作用是在C＋＋编译器中生成C的变量和函数符号</p><h4 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h4><p>我这里就不拷贝代码了，仅仅说一下几条方法和注意事项</p><blockquote><ol><li>类似于想 <em>static</em>这样的关键字 它即可以作用某一个具体的方法,也可以作用于代码块</li><li>由于经有C编译，有很多C++的特性是无法使用的，比如前面的函数重载</li><li>如果函数实现与申明同时被修饰，就像前面的重载申明与实现分离，申明肯定是要写上的，而实现是可有可无的。</li></ol></blockquote><h4 id="c与c混合编程注意事项"><a class="markdownIt-Anchor" href="#c与c混合编程注意事项"></a> C++与C混合编程注意事项</h4><h5 id="使用第三方库特指c开发的"><a class="markdownIt-Anchor" href="#使用第三方库特指c开发的"></a> 使用第三方库(特指C开发的)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在B站上找到的一个不错的C++入门实战，特做笔记
    
    </summary>
    
    
      <category term="C++" scheme="http://blog.kjvaa.online/categories/C/"/>
    
    
      <category term="C++" scheme="http://blog.kjvaa.online/tags/C/"/>
    
  </entry>
  
</feed>
